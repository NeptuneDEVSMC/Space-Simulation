<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulación 2D de planetas - Matter.js</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: #000;
    font-family: Arial, sans-serif;
    color: white;
  }
  #instructions {
    position: fixed; top: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
    max-width: 320px; font-size: 14px; line-height: 1.4;
    user-select: none;
  }
  canvas {
    display: block;
    background: radial-gradient(circle at center, #111111, #000000);
  }
</style>
</head>
<body>

<div id="instructions">
  <strong>Simulación 2D de Planetas</strong><br>
  - Click: crear planeta<br>
  - Tecla “1”: cambiar tamaño del planeta a crear<br>
  - Barra espaciadora: pausar/reanudar<br>
  - Tecla “R”: reiniciar (eliminar planetas)<br>
  <br>
  Tamaño actual del planeta: <span id="sizeDisplay"></span> px
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
(() => {
  const { Engine, Render, World, Bodies, Runner, Events, Vector } = Matter;

  // Configuración básica
  const engine = Engine.create();
  const world = engine.world;
  world.gravity.scale = 0; // desactivamos la gravedad por defecto (gravedad física)

  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  const context = canvas.getContext('2d');

  // Responsivo
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bounds.right = canvas.width;
    bounds.bottom = canvas.height;
  }
  window.addEventListener('resize', resize);
  resize();

  // Límites de la simulación (bordes invisibles para rebotar)
  const bounds = {
    left: 0,
    right: canvas.width,
    top: 0,
    bottom: canvas.height,
  };

  // Planetas almacenados
  const planets = [];

  // Parámetros para crear planetas
  const planetSizes = [10, 20, 30, 40, 50, 60, 80]; // radios disponibles
  let currentSizeIndex = 1; // empieza en 20 px
  const damping = 0.005; // amortiguación ligera para velocidad
  let paused = false;

  // Actualiza texto de tamaño actual
  const sizeDisplay = document.getElementById('sizeDisplay');
  function updateSizeDisplay() {
    sizeDisplay.textContent = planetSizes[currentSizeIndex];
  }
  updateSizeDisplay();

  // Función para color aleatorio vibrante (HSL con saturación y luminosidad altas)
  function randomVibrantColor() {
    const h = Math.floor(Math.random() * 360);
    const s = 80 + Math.random() * 20; // 80-100%
    const l = 50 + Math.random() * 30; // 50-80%
    return `hsl(${h}, ${s}%, ${l}%)`;
  }

  // Crear planeta
  function createPlanet(x, y, radius) {
    const mass = radius * radius * 0.001; // masa proporcional al área
    const body = Bodies.circle(x, y, radius, {
      mass: mass,
      restitution: 0.8,  // rebote suave
      frictionAir: damping, // amortiguación ligera para evitar caos total
      friction: 0,
      frictionStatic: 0,
      render: { fillStyle: randomVibrantColor() },
      // para controlar que no se salga
      collisionFilter: { group: -1 },
    });
    planets.push(body);
    World.add(world, body);
  }

  // Detectar click para crear planeta
  canvas.addEventListener('mousedown', e => {
    if (paused) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createPlanet(x, y, planetSizes[currentSizeIndex]);
  });

  // Cambiar tamaño al presionar "1"
  window.addEventListener('keydown', e => {
    if (e.key === '1') {
      currentSizeIndex = (currentSizeIndex + 1) % planetSizes.length;
      updateSizeDisplay();
    } else if (e.key === ' ') {
      // barra espaciadora pausa/reanuda
      paused = !paused;
      if (!paused) {
        lastTime = performance.now();
        Engine.run(engine);
      } else {
        Engine.clear(engine);
      }
    } else if (e.key.toLowerCase() === 'r') {
      // reiniciar
      for (const p of planets) {
        World.remove(world, p);
      }
      planets.length = 0;
    }
  });

  // Simulación gravitacional manual:
  // Aplicamos fuerza gravitacional entre planetas siguiendo ley inversa al cuadrado
  // F = G * m1 * m2 / r^2
  // G arbitrario para balancear la simulación
  const G = 0.0001;

  // Rebote contra bordes con rebote suave
  function handleBorders(body) {
    const pos = body.position;
    const r = body.circleRadius;

    let bounced = false;

    if (pos.x - r < bounds.left) {
      Body.setPosition(body, { x: bounds.left + r, y: pos.y });
      Body.setVelocity(body, { x: Math.abs(body.velocity.x) * 0.8, y: body.velocity.y });
      bounced = true;
    }
    if (pos.x + r > bounds.right) {
      Body.setPosition(body, { x: bounds.right - r, y: pos.y });
      Body.setVelocity(body, { x: -Math.abs(body.velocity.x) * 0.8, y: body.velocity.y });
      bounced = true;
    }
    if (pos.y - r < bounds.top) {
      Body.setPosition(body, { x: pos.x, y: bounds.top + r });
      Body.setVelocity(body, { x: body.velocity.x, y: Math.abs(body.velocity.y) * 0.8 });
      bounced = true;
    }
    if (pos.y + r > bounds.bottom) {
      Body.setPosition(body, { x: pos.x, y: bounds.bottom - r });
      Body.setVelocity(body, { x: body.velocity.x, y: -Math.abs(body.velocity.y) * 0.8 });
      bounced = true;
    }

    if (bounced) {
      // ligera amortiguación extra al rebotar para evitar energía infinita
      body.velocity.x *= 0.9;
      body.velocity.y *= 0.9;
    }
  }

  // Sin motor de render de Matter, hacemos dibujo manual:
  function draw() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    // Fondo suave con brillo al centro (ya con CSS pero reforzamos)
    const grad = context.createRadialGradient(canvas.width/2, canvas.height/2, 50, canvas.width/2, canvas.height/2, canvas.width/2);
    grad.addColorStop(0, '#222');
    grad.addColorStop(1, '#000');
    context.fillStyle = grad;
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Dibujar planetas
    for (const p of planets) {
      context.beginPath();
      context.fillStyle = p.render.fillStyle;
      context.shadowColor = p.render.fillStyle;
      context.shadowBlur = 15;
      context.arc(p.position.x, p.position.y, p.circleRadius, 0, 2 * Math.PI);
      context.fill();
      context.shadowBlur = 0;

      // Opcional: contorno blanco suave para verlos bien
      context.strokeStyle = 'rgba(255,255,255,0.2)';
      context.lineWidth = 1;
      context.stroke();
    }
  }

  // Aplicar fuerzas gravitacionales entre planetas
  function applyGravity() {
    for (let i = 0; i < planets.length; i++) {
      for (let j = i + 1; j < planets.length; j++) {
        const p1 = planets[i];
        const p2 = planets[j];

        const dir = Vector.sub(p2.position, p1.position);
        const distSq = Vector.magnitudeSquared(dir);

        // evitar división por cero o distancias muy pequeñas (separación mínima)
        const minDist = p1.circleRadius + p2.circleRadius;
        if (distSq < minDist * minDist) continue;

        const dist = Math.sqrt(distSq);
        const forceMag = G * p1.mass * p2.mass / distSq;
        const force = Vector.mult(Vector.normalise(dir), forceMag);

        // Aplicar fuerza opuesta a ambos planetas
        Body.applyForce(p1, p1.position, force);
        Body.applyForce(p2, p2.position, Vector.neg(force));
      }
    }
  }

  // Evento para amortiguar velocidad en cada tick (extra control)
  Events.on(engine, 'beforeUpdate', () => {
    if (paused) return;

    applyGravity();

    for (const p of planets) {
      handleBorders(p);
    }
  });

  // Tick con requestAnimationFrame para dibujar
  function tick() {
    if (!paused) Engine.update(engine);

    draw();

    requestAnimationFrame(tick);
  }

  // Iniciar simulación
  Engine.run(engine);
  tick();

})();
</script>

</body>
</html>
