<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulación gravitacional 2D - Matter.js</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    user-select: none;
  }
  #instructions {
    position: fixed;
    top: 10px; left: 10px;
    background: rgba(0,0,0,0.6);
    padding: 12px 16px;
    border-radius: 8px;
    max-width: 320px;
    font-size: 14px;
    line-height: 1.4;
  }
  canvas {
    display: block;
    background: #222;
  }
</style>
</head>
<body>

<div id="instructions">
  <strong>Controles:</strong><br>
  Click: crear planeta<br>
  Tecla <b>1</b>: cambiar tamaño del planeta a crear (radio actual: <span id="currentRadius">20</span>)<br>
  Barra espaciadora: pausar/reanudar simulación<br>
  Tecla <b>R</b>: reiniciar simulación<br>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
(() => {
  const {
    Engine,
    Render,
    Runner,
    World,
    Bodies,
    Body,
    Events,
    Vector
  } = Matter;

  // Crear motor y mundo
  const engine = Engine.create();
  const world = engine.world;
  world.gravity.scale = 0; // Desactivamos la gravedad global

  // Crear canvas responsivo
  const width = window.innerWidth;
  const height = window.innerHeight;

  const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      width,
      height,
      wireframes: false,
      background: '#222',
      pixelRatio: window.devicePixelRatio,
    }
  });

  Render.run(render);

  const runner = Runner.create();
  Runner.run(runner, engine);

  // Bordes del canvas para que los planetas reboten (static bodies)
  const thickness = 60;
  const borders = [
    Bodies.rectangle(width/2, -thickness/2, width, thickness, { isStatic: true }),
    Bodies.rectangle(width/2, height + thickness/2, width, thickness, { isStatic: true }),
    Bodies.rectangle(-thickness/2, height/2, thickness, height, { isStatic: true }),
    Bodies.rectangle(width + thickness/2, height/2, thickness, height, { isStatic: true }),
  ];
  World.add(world, borders);

  // Parámetros
  let planetRadiusOptions = [10, 20, 30, 40, 50];
  let radiusIndex = 1; // Empezamos con radio 20
  let creatingRadius = planetRadiusOptions[radiusIndex];
  const G = 0.0015; // Constante gravitacional ajustada para esta simulación
  const damping = 0.02; // Amortiguación ligera

  const planets = [];

  // Generar color vibrante aleatorio
  function getRandomVibrantColor() {
    // Colores saturados con hsl (hue random, saturación alta, luz media)
    const hue = Math.floor(Math.random() * 360);
    return `hsl(${hue}, 90%, 60%)`;
  }

  // Crear planeta en posición x,y con radio definido
  function createPlanet(x, y, r) {
    const mass = r * r; // Masa proporcional al área (radio²)
    const planet = Bodies.circle(x, y, r, {
      mass,
      restitution: 0.8, // rebote suave
      frictionAir: damping, // amortiguación para evitar caos total
      render: {
        fillStyle: getRandomVibrantColor()
      }
    });
    planets.push(planet);
    World.add(world, planet);
  }

  // Aplicar gravedad entre todos los planetas (ley inversa al cuadrado)
  Events.on(engine, 'beforeUpdate', () => {
    for(let i = 0; i < planets.length; i++) {
      for(let j = i + 1; j < planets.length; j++) {
        const bodyA = planets[i];
        const bodyB = planets[j];
        const dir = Vector.sub(bodyB.position, bodyA.position);
        const distSq = Vector.magnitudeSquared(dir);

        if (distSq === 0) continue; // evitar división por cero

        // Fuerza gravitacional: F = G * m1 * m2 / r²
        const forceMagnitude = G * bodyA.mass * bodyB.mass / distSq;

        // Dirección normalizada
        const force = Vector.mult(Vector.normalise(dir), forceMagnitude);

        // Aplicar fuerza en cuerpos opuestos
        Body.applyForce(bodyA, bodyA.position, force);
        Body.applyForce(bodyB, bodyB.position, Vector.neg(force));
      }
    }
  });

  // Control para crear planeta con click
  render.canvas.addEventListener('mousedown', e => {
    const rect = render.canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    createPlanet(mouseX, mouseY, creatingRadius);
  });

  // Controlar tamaño del planeta con tecla "1"
  window.addEventListener('keydown', e => {
    if(e.key === '1') {
      radiusIndex++;
      if(radiusIndex >= planetRadiusOptions.length) radiusIndex = 0;
      creatingRadius = planetRadiusOptions[radiusIndex];
      document.getElementById('currentRadius').textContent = creatingRadius;
    }
    else if(e.code === 'Space') {
      // Pausar o reanudar
      if(runner.enabled) {
        Runner.stop(runner);
      } else {
        Runner.run(runner, engine);
      }
    }
    else if(e.key.toLowerCase() === 'r') {
      // Reiniciar simulación: eliminar planetas y resetear lista
      for(const p of planets) {
        World.remove(world, p);
      }
      planets.length = 0;
    }
  });

  // Responsividad al cambiar tamaño de ventana
  window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    render.canvas.width = w;
    render.canvas.height = h;

    // Mover y actualizar bordes
    Body.setPosition(borders[0], { x: w/2, y: -thickness/2 });
    Body.setPosition(borders[1], { x: w/2, y: h + thickness/2 });
    Body.setPosition(borders[2], { x: -thickness/2, y: h/2 });
    Body.setPosition(borders[3], { x: w + thickness/2, y: h/2 });
  });
})();
</script>

</body>
</html>
