<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Simulación Espacial 2D con Matter.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.4);
      padding: 8px;
      border-radius: 4px;
      z-index: 10;
    }
  </style>
</head>
<body>

  <div id="info">
    <p><strong>Controles:</strong></p>
    <p>Click: crear planeta</p>
    <p>Espacio: pausa/reanudar</p>
    <p>R: reiniciar</p>
  </div>

  <canvas id="canvas"></canvas>

  <!-- Matter.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
    // Alias de Matter.js
    const { Engine, Render, Runner, World, Bodies, Body, Events, Vector } = Matter;

    const canvas = document.getElementById('canvas');
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Crear motor y mundo
    const engine = Engine.create();
    const world = engine.world;
    world.gravity.scale = 0; // quitamos gravedad vertical porque haremos gravedad manual

    // Crear render personalizado usando el canvas existente
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: width,
        height: height,
        wireframes: false,
        background: '#000',
      }
    });

    Render.run(render);

    // Runner para controlar simulación
    const runner = Runner.create();
    Runner.run(runner, engine);

    // Bordes (paredes) para que los planetas reboten suavemente
    const thickness = 50;
    const walls = [
      Bodies.rectangle(width/2, -thickness/2, width, thickness, { isStatic: true }),           // arriba
      Bodies.rectangle(width/2, height + thickness/2, width, thickness, { isStatic: true }),   // abajo
      Bodies.rectangle(-thickness/2, height/2, thickness, height, { isStatic: true }),         // izquierda
      Bodies.rectangle(width + thickness/2, height/2, thickness, height, { isStatic: true })   // derecha
    ];
    World.add(world, walls);

    // Planetas almacenados aquí
    const planets = [];

    // Constantes
    const G = 0.0015; // constante gravitacional ajustable para equilibrio visual

    // Crear planeta con masa proporcional al área y color random
    function createPlanet(x, y, radius) {
      const mass = radius * radius * 0.001;
      const color = `hsl(${Math.random()*360}, 80%, 60%)`;
      const planet = Bodies.circle(x, y, radius, {
        mass: mass,
        restitution: 0.8,
        frictionAir: 0.02,
        render: { fillStyle: color }
      });
      World.add(world, planet);
      planets.push(planet);
    }

    // Aplicar fuerza gravitacional entre todos los planetas (fuerza de atracción mutua)
    Events.on(engine, 'beforeUpdate', () => {
      for (let i = 0; i < planets.length; i++) {
        for (let j = i + 1; j < planets.length; j++) {
          const p1 = planets[i];
          const p2 = planets[j];

          const direction = Vector.sub(p2.position, p1.position);
          const distanceSq = Vector.magnitudeSquared(direction);

          if (distanceSq === 0) continue; // evitar división por cero

          const forceMagnitude = (G * p1.mass * p2.mass) / distanceSq;
          const force = Vector.normalise(direction);
          const forceVec = Vector.mult(force, forceMagnitude);

          // Aplicar fuerzas opuestas
          Body.applyForce(p1, p1.position, forceVec);
          Body.applyForce(p2, p2.position, Vector.neg(forceVec));
        }
      }
    });

    // Click para crear planeta, con velocidad inicial tangencial si hay planeta central
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const radius = 15;

      createPlanet(x, y, radius);

      if (planets.length > 1) {
        // Asumimos que el primer planeta es el central
        const central = planets[0];
        const newPlanet = planets[planets.length - 1];

        const dx = newPlanet.position.x - central.position.x;
        const dy = newPlanet.position.y - central.position.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          // Dirección tangencial para órbita
          const tangent = Vector.perp(Vector.normalise({ x: dx, y: dy }));

          // Velocidad orbital aproximada v = sqrt(G * M / r)
          const v = Math.sqrt((G * central.mass) / dist);

          // Establecemos velocidad tangencial para nuevo planeta
          Body.setVelocity(newPlanet, { x: tangent.x * v * 60, y: tangent.y * v * 60 }); 
          // Multiplico por 60 para que se note en pixeles/frame (ajusta según tu monitor)
        }
      }
    });

    // Pausar y reiniciar
    let paused = false;
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        paused = !paused;
        runner.enabled = !paused;
      } else if (e.key.toLowerCase() === 'r') {
        // Reiniciar
        for (const p of planets) {
          World.remove(world, p);
        }
        planets.length = 0;
      }
    });

    // Ajustar canvas al redimensionar ventana
    window.addEventListener('resize', () => {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
      Render.lookAt(render, {
        min: { x: 0, y: 0 },
        max: { x: window.innerWidth, y: window.innerHeight }
      });
    });

    // Crear planeta central grande al iniciar (el "sol")
    createPlanet(width/2, height/2, 40);
  </script>
</body>
</html>
