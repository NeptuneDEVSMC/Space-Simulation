<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulación gravitacional con Matter.js</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#111;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #instructions {
    position: fixed;
    top: 10px; left: 10px;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 6px;
    max-width: 320px;
    font-size: 14px;
    line-height: 1.4;
    z-index: 100;
  }
  canvas {
    display: block;
    background: #111;
  }
</style>
</head>
<body>
<div id="instructions">
  <b>Instrucciones:</b><br>
  • Click: crear planeta<br>
  • Tecla "1": cambiar tamaño del planeta a crear<br>
  • Barra espaciadora: pausar/reanudar<br>
  • Tecla "R": reiniciar (borrar planetas)<br>
  <br>
  <span id="sizeInfo">Tamaño actual: 20 px</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
(() => {
  const {
    Engine,
    Render,
    World,
    Bodies,
    Body,
    Events,
    Runner,
    Composite,
    Vector,
  } = Matter;

  // Configuración inicial
  let width = window.innerWidth;
  let height = window.innerHeight;

  const engine = Engine.create();
  const world = engine.world;

  // Amortiguación global para reducir velocidad (fricción del aire)
  world.gravity.y = 0; // no gravedad del mundo, solo entre planetas

  // Crear render
  const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      width,
      height,
      wireframes: false,
      background: '#111',
      pixelRatio: window.devicePixelRatio,
    },
  });

  Render.run(render);

  const runner = Runner.create();
  Runner.run(runner, engine);

  // Variables
  let planetRadius = 20; // tamaño inicial al crear
  const minRadius = 5;
  const maxRadius = 60;

  const planets = [];

  let paused = false;

  // Bordes invisibles para que planetas no salgan del canvas
  const wallThickness = 50;
  let walls = [];

  function createWalls() {
    // Quitar paredes viejas
    if(walls.length){
      for(const wall of walls){
        World.remove(world, wall);
      }
    }

    walls = [
      Bodies.rectangle(width/2, -wallThickness/2, width, wallThickness, { isStatic: true }),
      Bodies.rectangle(width/2, height+wallThickness/2, width, wallThickness, { isStatic: true }),
      Bodies.rectangle(-wallThickness/2, height/2, wallThickness, height, { isStatic: true }),
      Bodies.rectangle(width+wallThickness/2, height/2, wallThickness, height, { isStatic: true }),
    ];
    World.add(world, walls);
  }
  createWalls();

  // Función para color vibrante aleatorio
  function randomVibrantColor(){
    const r = Math.floor(155 + Math.random()*100);
    const g = Math.floor(155 + Math.random()*100);
    const b = Math.floor(155 + Math.random()*100);
    return `rgb(${r},${g},${b})`;
  }

  // Crear planeta
  function createPlanet(x, y, radius) {
    // Masa proporcional al área (radio²)
    const mass = radius * radius;

    // Cuerpo circular con fricción y restitution para rebote suave
    const planet = Bodies.circle(x, y, radius, {
      mass,
      restitution: 0.8,
      frictionAir: 0.02,
      render: {
        fillStyle: randomVibrantColor(),
      },
    });
    planets.push(planet);
    World.add(world, planet);
  }

  // Atracción gravitacional inversa al cuadrado entre planetas
  // G es constante para ajustar fuerza
  const G = 0.0015;

  Events.on(engine, "beforeUpdate", () => {
    if(paused) return;

    // Aplicar fuerza gravitacional entre planetas
    for(let i = 0; i < planets.length; i++){
      for(let j = i+1; j < planets.length; j++){
        const bodyA = planets[i];
        const bodyB = planets[j];

        const delta = Vector.sub(bodyB.position, bodyA.position);
        const distSq = Vector.magnitudeSquared(delta);

        if(distSq === 0) continue; // evitar división por 0

        const forceMagnitude = (G * bodyA.mass * bodyB.mass) / distSq;

        // Dirección normalizada
        const force = Vector.mult(Vector.normalise(delta), forceMagnitude);

        Body.applyForce(bodyA, bodyA.position, force);
        Body.applyForce(bodyB, bodyB.position, Vector.neg(force));
      }
    }

    // Pequeña amortiguación manual para evitar caos total
    for(const p of planets){
      Body.setVelocity(p, {
        x: p.velocity.x * 0.995,
        y: p.velocity.y * 0.995,
      });
    }
  });

  // Crear planeta al hacer click
  window.addEventListener("mousedown", e => {
    if(e.button !== 0) return; // solo click izquierdo
    const rect = render.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createPlanet(x, y, planetRadius);
  });

  // Cambiar tamaño planeta con tecla "1"
  window.addEventListener("keydown", e => {
    if(e.key === "1"){
      // Cambiar tamaño cíclicamente
      planetRadius += 10;
      if(planetRadius > maxRadius) planetRadius = minRadius;
      document.getElementById("sizeInfo").textContent = `Tamaño actual: ${planetRadius} px`;
    }
    else if(e.key === " "){
      // Pausar o reanudar
      paused = !paused;
      e.preventDefault();
    }
    else if(e.key.toLowerCase() === "r"){
      // Reiniciar todo
      for(const p of planets){
        World.remove(world, p);
      }
      planets.length = 0;
    }
  });

  // Responsivo canvas
  window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight;
    render.canvas.width = width;
    render.canvas.height = height;
    render.options.width = width;
    render.options.height = height;
    Render.lookAt(render, {
      min: { x: 0, y: 0 },
      max: { x: width, y: height }
    });
    createWalls();
  });

})();
</script>
</body>
</html>
