<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulación 2D de Sistema Espacial</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #000;
    user-select: none;
    font-family: monospace;
    color: #eee;
  }
  #canvas {
    display: block;
  }
  #info {
    position: fixed;
    top: 5px; left: 5px;
    background: rgba(0,0,0,0.6);
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 14px;
    max-width: 320px;
    line-height: 1.3em;
    user-select: none;
  }
  #status {
    position: fixed;
    top: 5px; left: 5px;
    font-family: monospace;
    font-size: 14px;
    color: #eee;
    background: rgba(0,0,0,0.75);
    padding: 6px 10px;
    border-radius: 5px;
    pointer-events: none;
    user-select: none;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="info">
  <b>Controles:</b><br>
  1: Cambiar masa (actual: <span id="massDisplay">1</span>)<br>
  2: Cambiar tamaño (actual: <span id="radiusDisplay">1</span>)<br>
  3: Cambiar velocidad inicial (actual: <span id="speedDisplay">5</span>)<br>
  Click: Crear planeta con propiedades actuales y velocidad hacia el click<br>
  R: Reiniciar simulación<br>
  Espacio: Pausar / Reanudar<br>
</div>

<div id="status">
  Masa: <span id="massStatus">1</span><br>
  Tamaño: <span id="radiusStatus">1</span><br>
  Velocidad inicial: <span id="speedStatus">5</span>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let W, H;
  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  window.addEventListener('resize', resize);
  resize();

  // UI display spans
  const massDisplay = document.getElementById('massDisplay');
  const radiusDisplay = document.getElementById('radiusDisplay');
  const speedDisplay = document.getElementById('speedDisplay');

  const massStatus = document.getElementById('massStatus');
  const radiusStatus = document.getElementById('radiusStatus');
  const speedStatus = document.getElementById('speedStatus');

  // Parámetros ajustables
  let mass = 1;    // 1 a 15
  let radius = 1;  // 1 a 10
  let initSpeed = 5;  // 5 a 20

  // Gravedad universal simplificada
  const G = 0.5; // Constante gravitacional ajustada para estabilidad visual

  // Planeta estructura
  class Planet {
    constructor(x, y, mass, radius, vx, vy, color) {
      this.x = x;
      this.y = y;
      this.mass = mass;
      this.radius = radius;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
    }

    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 10;
      ctx.arc(this.x, this.y, this.radius * 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // Lista de planetas
  let planets = [];

  // Simulación pausada o no
  let paused = false;

  // Función para generar color aleatorio
  function randomColor() {
    const r = 100 + Math.floor(Math.random() * 155);
    const g = 100 + Math.floor(Math.random() * 155);
    const b = 100 + Math.floor(Math.random() * 155);
    return `rgb(${r},${g},${b})`;
  }

  // Actualiza los valores en el DOM
  function updateUI() {
    massDisplay.textContent = mass;
    radiusDisplay.textContent = radius;
    speedDisplay.textContent = initSpeed;

    massStatus.textContent = mass;
    radiusStatus.textContent = radius;
    speedStatus.textContent = initSpeed;
  }
  updateUI();

  // Cambiar valores con teclas
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    switch(e.key) {
      case '1':
        mass = (mass === 15) ? 1 : mass + 1;
        updateUI();
        break;
      case '2':
        radius = (radius === 10) ? 1 : radius + 1;
        updateUI();
        break;
      case '3':
        initSpeed = (initSpeed === 20) ? 5 : initSpeed + 1;
        updateUI();
        break;
      case 'r':
      case 'R':
        planets = [];
        break;
      case ' ':
        paused = !paused;
        break;
    }
  });

  // Crear planeta al click
  canvas.addEventListener('click', e => {
    // Posición del click
    const cx = e.clientX;
    const cy = e.clientY;

    // Centro del canvas para calcular dirección
    const centerX = W/2;
    const centerY = H/2;

    // Vector dirección del centro al click
    let dx = cx - centerX;
    let dy = cy - centerY;
    const dist = Math.hypot(dx, dy);

    // Evitar división por cero
    if (dist === 0) {
      dx = 1;
      dy = 0;
    } else {
      dx /= dist;
      dy /= dist;
    }

    // Velocidad inicial en dirección click con magnitud aleatoria cerca del initSpeed
    const speedMag = initSpeed * (0.8 + 0.4 * Math.random());
    const vx = dx * speedMag;
    const vy = dy * speedMag;

    // Color aleatorio
    const color = randomColor();

    // Crear planeta
    planets.push(new Planet(cx, cy, mass, radius, vx, vy, color));
  });

  // Actualizar física y posición
  function updatePhysics(dt) {
    const accelerations = planets.map(() => ({ax:0, ay:0}));

    for(let i = 0; i < planets.length; i++) {
      for(let j = i+1; j < planets.length; j++) {
        const p1 = planets[i];
        const p2 = planets[j];

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distSq = dx*dx + dy*dy;
        const dist = Math.sqrt(distSq);

        if(dist > 0.1) {
          const force = G * p1.mass * p2.mass / distSq;
          const nx = dx / dist;
          const ny = dy / dist;
          const a1 = force / p1.mass;
          const a2 = force / p2.mass;

          accelerations[i].ax += nx * a1;
          accelerations[i].ay += ny * a1;
          accelerations[j].ax -= nx * a2;
          accelerations[j].ay -= ny * a2;
        }
      }
    }

    for(let i = 0; i < planets.length; i++) {
      const p = planets[i];
      const a = accelerations[i];

      p.vx += a.ax * dt;
      p.vy += a.ay * dt;

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // Bordes rebotan suavemente
      if (p.x - p.radius*4 < 0) {
        p.x = p.radius*4;
        p.vx *= -0.6;
      }
      else if (p.x + p.radius*4 > W) {
        p.x = W - p.radius*4;
        p.vx *= -0.6;
      }
      if (p.y - p.radius*4 < 0) {
        p.y = p.radius*4;
        p.vy *= -0.6;
      }
      else if (p.y + p.radius*4 > H) {
        p.y = H - p.radius*4;
        p.vy *= -0.6;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    const grad = ctx.createRadialGradient(W/2, H/2, W/10, W/2, H/2, W/2);
    grad.addColorStop(0, '#111');
    grad.addColorStop(1, '#000');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    for(const p of planets) {
      p.draw(ctx);
    }
  }

  let lastTime = performance.now();

  function loop(t) {
    const dt = (t - lastTime) / 1000;
    lastTime = t;

    if(!paused) {
      updatePhysics(dt);
    }
    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
